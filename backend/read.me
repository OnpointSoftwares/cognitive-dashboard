# 1. Store the raw JSON content from the Canvas file as a literal string.
$jsonBody = '{
"user_id": "ddos_tester_123",
"ip_address": "10.0.0.99",
"user_agent": "Mozilla/5.0 (Custom Request)",
"http_method": "GET",
"request_uri": "/api/v1/status",
"request_body": "healthcheck"
}'

# 2. Execute the POST request, explicitly using the JSON string in the -Body parameter.
Invoke-RestMethod -Uri http://127.0.0.1:8000/api/v1/detect -Method Post -ContentType 'application/json' -Body $jsonBody

The Project addresses the need to evolve traditional firewalls with intelligent threat detection. The models Used are(trained on CICIDS2017 and NSL-KDD) and are fundamentally Network Intrusion Detection (NID) models.

Integrating them into an "AI Firewall" (which acts more like an Intrusion Prevention System or IPS) requires a robust, real-time pipeline.

Here is a step-by-step breakdown of how the models were integrated into the firewall AI models into such a project:
New: [packet_sniffer.py]→[feature_extractor.py]→[AI detection module]→[firewall_enforcer.py]→System Action

Phase 1: Architectural Placement and Real-Time Capture
The models themselves do not replace the firewall; they act as a high-speed intelligence layer.

AI Firewall Architecture:

The overall system should be structured as an Intrusion Prevention System (IPS) with a deep packet inspection (DPI) capability.

Traffic should be mirrored or passed through the AI component before the final allow/deny decision is made by the core firewall engine.

Real-Time Packet Capture:

Tooling: Use high-performance packet capture libraries (e.g., DPDK, libpcap/Scapy in Python, or native Go/Rust network listeners) to intercept network traffic in real-time.

Flow Reconstruction: An individual network connection (a "flow") consists of multiple packets. The models were trained on flow-based features. You need a module to aggregate packets (Source IP, Destination IP, Ports, Protocol) into a flow and calculate features over a short time window (e.g., 5 seconds).

Phase 2: Feature Engineering (The Critical Bottleneck)
The biggest challenge is converting raw network traffic into the specific feature sets that NSL-KDD (41 features) and CICIDS2017 (78 features) were trained on, and doing this instantly.

Feature Type	NSL-KDD / CICIDS2017 Features	Real-Time Implementation
Basic	Protocol, Service, Flag, Source/Destination IP/Port.	Direct extraction from packet headers.
Content	count, srv_count, dst_host_count (Number of connections to/from a host in the last N seconds).	Requires maintaining stateful, time-based tables for all active connections and hosts.
Time-Window	duration, pkt_rate, byte_rate (Features aggregated over a 2-second or 5-second window).	Requires a precise timer logic to calculate and flush features for the model every few seconds.
Preprocessing	One-Hot Encoding for categorical features, Min-Max Normalization.	Must be applied dynamically to the extracted features before model input.

Export to Sheets
The Model Input Pipeline:

Raw Packet→Flow Reconstruction→Feature Calculation→Real-Time Preprocessing→Model Input Vector
Phase 3: Real-Time Inference and Output
Model Optimization:

The trained models must be converted into a format optimized for speed (e.g., ONNX, or a highly efficient library like TensorFlow Lite or a pre-compiled model for a language like C++ or Go).

Choose the model architecture carefully: Decision Trees/Random Forests are often preferred for this task over deep learning models because of their lower latency/faster inference time.

Inference Engine:

Load the trained NSL-KDD and CICIDS2017 models into a dedicated, low-latency service (the Detection Engine).

This engine receives the feature vector from the Feature Engineering step and returns a prediction immediately.

Output Interpretation:

The model output will be a classification (e.g., Normal, DoS, PortScan, U2R, R2L).

For a firewall/IPS, anything that is not Normal is an alarm. You may also need a confidence threshold (e.g., only block if the model is >95% sure it's an attack) to minimize false positives.

Phase 4: Decision and Enforcement (The Firewall Logic)
This is the point where the AI model's intelligence turns into a firewall action.

Action Mapping: Map the model's output to an enforcement action:

Prediction: Normal → Action: ALLOW (Pass the packet to the next rule in the traditional firewall chain).

Prediction: DoS, Botnet → Action: DROP or REJECT (Immediately block all subsequent packets from the source IP for a timeout period).

Prediction: U2R, R2L (Less frequent, more subtle attacks) → Action: ALERT and LOG (Generate a high-priority alert for human review, and potentially throttle the connection).

Rule Insertion: The AI component should have an interface to dynamically insert temporary block rules into the core firewall engine (e.g., using iptables or a proprietary API).

Key Challenges and Considerations
False Positives (The Biggest Risk): NSL-KDD and CICIDS2017 are academic datasets that often lead to models with high accuracy but poor generalization on real-world, live network traffic. A high False Positive Rate (blocking legitimate traffic) will make the "firewall" unusable. You need extensive real-world testing and a high confidence threshold for blocking.

Zero-Day Attacks: The models are trained on known attacks from the datasets. They will likely struggle with novel (zero-day) attacks. To mitigate this, consider integrating an Unsupervised Anomaly Detection model (e.g., Autoencoder or Isolation Forest) as a secondary detection engine.

Performance and Latency: An AI firewall must process traffic in microseconds to avoid introducing network lag. The entire feature extraction and inference pipeline must be extremely optimized and may require powerful hardware (e.g., a GPU or FPGA for high-volume networks).

Feature Drift and Maintenance: Real network traffic patterns change constantly. Your models will need a robust Continuous Integration/Continuous Deployment (CI/CD) pipeline for retraining and deployment to keep up with new normal behavior and new attacks.
Building Docker container file 
docker build -t ai-nips-integrated .
